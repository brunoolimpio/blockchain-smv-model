MODULE Network
-- STEP 1: Create a peer-to-peer network of 5 nodes.

	VAR
		node1 : integer;
		node2 : integer;
		node3 : integer;
		node4 : integer;
		node5 : integer; 
		node6 : integer;
		node7 : integer;
		adj1 : word[5];
		adj2 : word[5];

	ASSIGN
		next(adj1) := case
						node1 : node2;
						node2 : node3;
						node3 : node4;
						node4 : node5;
						node5 : node6;
						node6 : node7;
						node7 : node1;						
						TRUE : 0;
					esac;

		next(adj2) := case
						node7 : node6;
						node6 : node5;
						node5 : node4;
						node4 : node3;
						node3 : node2;
						node2 : node1;
						node1 : node7;
						TRUE : 0;
					esac;


MODULE Users(id, balance)
--STEP2: Create 3 users with [ID,Balance]

	VAR
		user1 : array 1..2 of integer;
		user2 : array 1..2 of integer;
		user3 : array 1..2 of integer;
	

	ASSIGN
		init(user1[1]) := 1;
		init(user1[2]) := 8;
		init(user2[1]) := 2;
		init(user1[2]) := 3;
		init(user3[1]) := 3;
		init(user3[2]) := 15;
			
	

MODULE createTransaction(transactionId, from, balFrom, to, balTo, amount, transactionsList)
--Step 2: A sender and a receiver create a transaction. It's just a value transfer from one to another.

	VAR		
		transaction : array 1..4 of integer;		
	
	DEFINE
		
		fromHasBalance :=  balFrom >= amount; --- Does the sender user have enough balance?

	
	ASSIGN
	
		next(from[2]) := case
							fromHasBalance : from[1] - amount;
							TRUE : from[1];
						esac;

		next(to[2]) := case
						fromHasBalance : to[1] + amount;
						TRUE : 
						to[1];
					esac;

		
		-- FEITO COM IF --
		next(transactionsList[1][1]) := transactionsList[1][1] = 0 ? transactionId : transactionsList[1][1];


		/-- next(transactionsList[1][1]) := case
		--								transactionsList[1][1] = 0 : transactionId;
		--								TRUE : transactionsList[1][1];
		--							esac;
		--/
		next(transactionsList[1][2]) := case
										transactionsList[1][1] = 0 : from;
										TRUE : transactionsList[1][2];
									esac;


		next(transactionsList[1][3]) := case
										transactionsList[1][1] = 0 : to;
										TRUE : transactionsList[1][3];
									esac;

		next(transactionsList[1][4]) := case
										transactionsList[1][1] = 0 & transactionsList[1][1] < transactionId: amount;
										TRUE : transactionsList[1][4];
									esac;


		next(transactionsList[2][1]) := case
										transactionsList[2][1] = 0 & transactionsList[1][1] < transactionId: transactionId;
										TRUE : transactionsList[2][1];
									esac;

		next(transactionsList[2][2]) := case
										transactionsList[2][1] = 0 & transactionsList[1][1] < transactionId: from;
										TRUE : transactionsList[2][2];
									esac;


		next(transactionsList[2][3]) := case
										transactionsList[2][1] = 0 & transactionsList[1][1] < transactionId: to;
										TRUE : transactionsList[2][3];
									esac;

		next(transactionsList[2][4]) := case
										transactionsList[2][1] = 0 & transactionsList[1][1] < transactionId: amount;
										TRUE : transactionsList[2][4];
									esac;


		next(transactionsList[3][1]) := case
										transactionsList[3][1] = 0 & transactionsList[2][1] < transactionId: transactionId;
										TRUE : transactionsList[3][1];
									esac;

		next(transactionsList[3][2]) := case
										transactionsList[3][1] = 0 & transactionsList[2][1] < transactionId: from;
										TRUE : transactionsList[3][2];
									esac;


		next(transactionsList[3][3]) := case
										transactionsList[3][1] = 0 & transactionsList[2][1] < transactionId: to;
										TRUE : transactionsList[3][3];
									esac;

		next(transactionsList[3][4]) := case
										transactionsList[4][1] = 0 & transactionsList[2][1] < transactionId: amount;
										TRUE : transactionsList[3][4];
									esac;
		

		next(transactionsList[4][1]) := case
										transactionsList[4][1] = 0 & transactionsList[3][1] < transactionId: transactionId;
										TRUE : transactionsList[4][1];
									esac;

		next(transactionsList[4][2]) := case
										transactionsList[4][1] = 0 & transactionsList[3][1] < transactionId: from;
										TRUE : transactionsList[4][2];
									esac;


		next(transactionsList[4][3]) := case
										transactionsList[4][1] = 0 & transactionsList[3][1] < transactionId: to;
										TRUE : transactionsList[4][3];
									esac;

		next(transactionsList[4][4]) := case
										transactionsList[2][1] = 0 & transactionsList[3][1] < transactionId: amount;
										TRUE : transactionsList[4][4];
									esac;


		next(transactionsList[5][1]) := case
										transactionsList[5][1] = 0 & transactionsList[4][1] < transactionId: transactionId;
										TRUE : transactionsList[5][1];
									esac;

		next(transactionsList[5][2]) := case
										transactionsList[5][1] = 0 & transactionsList[4][1] < transactionId: from;
										TRUE : transactionsList[5][2];
									esac;


		next(transactionsList[5][3]) := case
										transactionsList[5][1] = 0 & transactionsList[4][1] < transactionId: to;
										TRUE : transactionsList[5][3];
									esac;

		next(transactionsList[5][4]) := case
										transactionsList[5][1] = 0 & transactionsList[4][1] < transactionId: amount;
										TRUE : transactionsList[5][4];
									esac;


-------TODO: Garantir que duas transações para o mesmo usuário não gerem inconsistências.



-- Step 2: #TODO: Should have a MODULE to encrypt transactions.
--			Ideally it would be the same to encrypt everything (transactions, blocks, addresses...).


MODULE createBlock (blockId, transactionsList, previousBlockId)
-- Step 3: Several transactions are put together and encrypted creating a block.
--		   Each block contains into it an identification of the previous block, wich chains the blocks.

	VAR
		blockId : integer;
		blockCreated : boolean;
		timestamp : integer;
		previousBlockId : 1..3;
		listBlock : array 1..10 of array 1..4 of unsigned word[10];
		blockTransactions : array 1..3 of integer;


	ASSIGN
		next(blockTransactions) := {transactionsList[1][1],transactionsList[2][1], transactionsList[3][1]};
		init(id) := 1;
		init(timestamp) := 1;
		next(blockId) := blockId + 1;
		next(timestamp) := timestamp + 1;
		next(blockCreated) := listBlock[blockId] = {blockId, timestamp, blockTransactions, previousBlockId};						


MODULE searchBlock(requester, adj1, adj2, nodesList)
	
	VAR
		requester : 1..7;
		

	DEFINE

		hasNewBlock := nodesList[requester][1] < nodesList[adj1][1] |		--- Compares the last block of the requester 
					   nodesList[requester][1] < nodesList[adj2][1];

	ASSIGN

		next(adj1) := case 
						requester = 1 : 3;
						requester = 2 : 3;
						requester = 3 : 1;
						requester = 4 : 1;
						requester = 5 : 1;
						TRUE : 0;
					esac;

		next(adj2) := case
						requester = 1 : 4;										
						requester = 3 : 2;
						requester = 4 : 3;
						requester = 5 : 4;
						TRUE : 0;							
					esac;


MODULE broadcast(sender, blockId)
-- Step 4: Once a node created a block, it should be broadcasted to the entire network.
	VAR
		sender : word[5];
		blockId : 1..3;
		checkNodes : searchBlock(sender, adj1, adj2, nodesList);
		
	DEFINE

--		checkNodes := searchBlock(sender, adj1, adj2, adj3, nodesList);	--- Verify if each one of the adjacent
																		--- nodes is up-to-date		
		sendLastBlock := checkNodes.hasNewBlock;

	ASSIGN

		next(nodesList[sender][1]) :=  case	
										sendLastBlock : nodesList[sender][1]+1;
										TRUE : nodesList[sender][1];
									esac;


MODULE main
	VAR
		transactionsList : array 1..10 of array 1..4 of integer;  --transactionsList: [ID, from, to, amount]
		
		t1 : createTransaction(1, user1, user2, 3, transactionsList);
		t2 : createTransaction(2, user1, user3, 5, transactionsList);
		t3 : createTransaction(3, user2, user1, 7, transactionsList);
		t4 : createTransaction(4, user3, user2, 4, transactionsList);
		t5 : createTransaction(5, user1, user2, 12, transactionsList);

	

		