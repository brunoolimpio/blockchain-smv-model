MODULE createNetwork
	VAR
		node1, node2, node3, node4, node5, node6, node7 : integer;
		adj1, adj2 : integer;

	DEFINE
		next(adj1) := case
						node1 : node2;
						node2 : node3;
						node3 : node4;
						node4 : node5;
						node5 : node6;
						node6 : node7;
						node7 : node1;						
						TRUE : 0;
					esac;

		next(adj2) := case
						node7 : node6;
						node6 : node5;
						node5 : node4;
						node4 : node3;
						node3 : node2;
						node2 : node1;
						node1 : node7;
						TRUE : 0;
					esac;


MODULE createTransaction(transactionId, from, to, amount, listTransaction)
--Step 2: A sender and a receiver create a transaction. It's just a value transfer from one to another.

	VAR		
		transaction : array 1..4 of integer;
		fromHasBalance : boolean;
		isValid : boolean;

	DEFINE
		fromHasBalance :=  from[2] >= amount; --- Does the sender have enough balance?
		isValid := fromHasBalance & from != to

	
	ASSIGN
		next(from[2]) := case
							isValid : from[2] - amount;
							TRUE : from[2];
						esac;

		next(to[2]) := case
						isValid : to[2] + amount;
						TRUE : to[2];
					esac;


		next(listTransaction[1]) := case
										listTransaction[1][1] = 0 : {transactionId, from, to, amount};
										TRUE : listTransaction[1];
									esac;

		next(listTransaction[2]) := case
										listTransaction[2][1] = 0 & listTransaction[1][1] < transactionId: {transactionId, from, to, amount};
										TRUE : listTransaction[2];
									esac;

		next(listTransaction[3]) := case
										listTransaction[3][1] = 0 & listTransaction[2][1] < transactionId : {transactionId, from, to, amount};
										TRUE : listTransaction[3];
									esac;

		next(listTransaction[4]) := case
										listTransaction[4][1] = 0 & listTransaction[3][1] < transactionId : {transactionId, from, to, amount};
										TRUE : listTransaction[4];
									esac;

		next(listTransaction[5]) := case
										listTransaction[5][1] = 0 & listTransaction[4][1] < transactionId : {transactionId, from, to, amount};
										TRUE : listTransaction[5];
									esac;

-- Step 2: #TODO: Should have a MODULE to encrypt transactions.
--			Ideally it would be the same to encrypt everything (transactions, blocks, addresses...).


MODULE createBlock (blockId, listTransaction, previousBlockId)
-- Step 3: Several transactions are put together and encrypted creating a block.
--		   Each block contains into it an identification of the previous block, wich chains the blocks.

	VAR
		blockId : integer;
		blockCreation : boolean;
		timestamp : integer;
		previousBlockId : integer;
		listBlock := array 1..10 of array 1..4 of unsigned word[10];
		blockTransactions := array 1..3 of integer;


	ASSIGN
		next(blockTransactions) := {listTransaction[1][1],listTransaction[2][1], listTransaction[3][1]};
		init(id) := 1;
		init(timestamp) := 1;
		next(blockId) := blockId + 1;
		next(timestamp) := timestamp + 1;
		next(blockCreation) := listBlock[blockId] = {blockId, timestamp, blockTransactions, previousBlockId};						


-- #TODO: Define a peer-to-peer network.

MODULE searchBlock(requester, adj1, adj2, listNode)
	
	VAR
		requester : integer;
		

	DEFINE

		hasNewBlock := listNode[requester][1] < listNode[adj1][1] |		--- Compares the last block of the requester 
					   listNode[requester][1] < listNode[adj2][1] |		--- and  adjacent node.
		 			   listNode[requester][1] < listNode[adj3][1];

	ASSIGN

		next(adj1) := case 
						requester = 1 : 3;
						requester = 2 : 3;
						requester = 3 : 1;
						requester = 4 : 1;
						requester = 5 : 1;
						TRUE : 0;
					esac;

		next(adj2) := case
						requester = 1 : 4;										
						requester = 3 : 2;
						requester = 4 : 3;
						requester = 5 : 4;
						TRUE : 0;							
					esac;


MODULE broadcast(sender, blockId)
-- Step 4: Once a node created a block, it should be broadcasted to the entire network.
	VAR
		sender : integer;
		blockId : integer;

	DEFINE

		checkNodes : searchBlock(sender, adj1, adj2, adj3, listNode);	--- Verify if each one of the adjacent																		--- nodes is up-to-date
		
		sendLastBlock := checkNodes.hasNewBlock;

		upToDate := broadcast(sender, blockId)
	ASSIGN

		next(listNode[sender][1]) :=  case	
										sendLastBlock : listNode[sender][1]+1
										TRUE : listNode[sender][1];
									esac;


MODULE main
	VAR
		user1, user2, user3 : array 1..2 of integer;
		listTransaction : array 1..10 of array 1..4 of integer;

		t1 : createTransaction(1, user1, user2, 3, listTransaction);
		t2 : createTransaction(2, user1, user3, 5, listTransaction);
		t3 : createTransaction(3, user2, user1, 7, listTransaction);
		t4 : createTransaction(4, user3, user2, 4, listTransaction);
		t5 : createTransaction(5, user1, user2, 12, listTransaction);

	DEFINE
		init(user1) : {1, 8};
		init(user2) : {2, 5};
		init(user3) : {3, 15};
	ASSIGN

		--init(n) := 1;
		--next(n) := case 
		--			(n mod 2) != 0 & (n mod 3) != 0 & (n mod 5) != 0 & (n mod 7 != 0): primeNumber := n;
		--		esac;