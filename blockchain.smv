MODULE createNetwork
-- STEP 1: Create a peer-to-peer network of 5 nodes.

	VAR
		node1 : integer;
		node2 : integer;
		node3 : integer;
		node4 : integer;
		node5 : integer; 
		node6 : integer;
		node7 : integer;
		adj1 : word[5];
		adj2 : word[5];

	ASSIGN
		next(adj1) := case
						node1 : node2;
						node2 : node3;
						node3 : node4;
						node4 : node5;
						node5 : node6;
						node6 : node7;
						node7 : node1;						
						TRUE : 0;
					esac;

		next(adj2) := case
						node7 : node6;
						node6 : node5;
						node5 : node4;
						node4 : node3;
						node3 : node2;
						node2 : node1;
						node1 : node7;
						TRUE : 0;
					esac;


MODULE createUsers (id, balance)

	VAR
		user : array 1..2 of integer;
	
	DEFINE
		user[1] := id;
		user[2] := balance;



MODULE createTransaction(transactionId, from, to, amount, listTransaction)
--Step 2: A sender and a receiver create a transaction. It's just a value transfer from one to another.

	VAR		
		transaction : array 1..4 of integer;		
	
	DEFINE
		fromHasBalance :=  from[2] >= amount; --- Does the sender user have enough balance?

	
	ASSIGN
	
		next(from[2]) := case
							fromHasBalance : from[2] - amount;
							TRUE : from[2];
						esac;

		next(to[2]) := case
						fromHasBalance : to[2] + amount;
						TRUE : 
						to[2];
					esac;

		
		-- FEITO COM IF --
		next(listTransaction[1][1]) := listTransaction[1][1] = 0 ? transactionId : listTransaction[1][1];


		/-- next(listTransaction[1][1]) := case
		--								listTransaction[1][1] = 0 : transactionId;
		--								TRUE : listTransaction[1][1];
		--							esac;
		--/
		next(listTransaction[1][2]) := case
										listTransaction[1][1] = 0 : from;
										TRUE : listTransaction[1][2];
									esac;


		next(listTransaction[1][3]) := case
										listTransaction[1][1] = 0 : to;
										TRUE : listTransaction[1][3];
									esac;

		next(listTransaction[1][4]) := case
										listTransaction[1][1] = 0 & listTransaction[1][1] < transactionId: amount;
										TRUE : listTransaction[1][4];
									esac;


		next(listTransaction[2][1]) := case
										listTransaction[2][1] = 0 & listTransaction[1][1] < transactionId: transactionId;
										TRUE : listTransaction[2][1];
									esac;

		next(listTransaction[2][2]) := case
										listTransaction[2][1] = 0 & listTransaction[1][1] < transactionId: from;
										TRUE : listTransaction[2][2];
									esac;


		next(listTransaction[2][3]) := case
										listTransaction[2][1] = 0 & listTransaction[1][1] < transactionId: to;
										TRUE : listTransaction[2][3];
									esac;

		next(listTransaction[2][4]) := case
										listTransaction[2][1] = 0 & listTransaction[1][1] < transactionId: amount;
										TRUE : listTransaction[2][4];
									esac;


		next(listTransaction[3][1]) := case
										listTransaction[3][1] = 0 & listTransaction[2][1] < transactionId: transactionId;
										TRUE : listTransaction[3][1];
									esac;

		next(listTransaction[3][2]) := case
										listTransaction[3][1] = 0 & listTransaction[2][1] < transactionId: from;
										TRUE : listTransaction[3][2];
									esac;


		next(listTransaction[3][3]) := case
										listTransaction[3][1] = 0 & listTransaction[2][1] < transactionId: to;
										TRUE : listTransaction[3][3];
									esac;

		next(listTransaction[3][4]) := case
										listTransaction[4][1] = 0 & listTransaction[2][1] < transactionId: amount;
										TRUE : listTransaction[3][4];
									esac;
		

		next(listTransaction[4][1]) := case
										listTransaction[4][1] = 0 & listTransaction[3][1] < transactionId: transactionId;
										TRUE : listTransaction[4][1];
									esac;

		next(listTransaction[4][2]) := case
										listTransaction[4][1] = 0 & listTransaction[3][1] < transactionId: from;
										TRUE : listTransaction[4][2];
									esac;


		next(listTransaction[4][3]) := case
										listTransaction[4][1] = 0 & listTransaction[3][1] < transactionId: to;
										TRUE : listTransaction[4][3];
									esac;

		next(listTransaction[4][4]) := case
										listTransaction[2][1] = 0 & listTransaction[3][1] < transactionId: amount;
										TRUE : listTransaction[4][4];
									esac;


		next(listTransaction[5][1]) := case
										listTransaction[5][1] = 0 & listTransaction[4][1] < transactionId: transactionId;
										TRUE : listTransaction[5][1];
									esac;

		next(listTransaction[5][2]) := case
										listTransaction[5][1] = 0 & listTransaction[4][1] < transactionId: from;
										TRUE : listTransaction[5][2];
									esac;


		next(listTransaction[5][3]) := case
										listTransaction[5][1] = 0 & listTransaction[4][1] < transactionId: to;
										TRUE : listTransaction[5][3];
									esac;

		next(listTransaction[5][4]) := case
										listTransaction[5][1] = 0 & listTransaction[4][1] < transactionId: amount;
										TRUE : listTransaction[5][4];
									esac;


-------TODO: Garantir que duas transações para o mesmo usuário não gerem inconsistências.



-- Step 2: #TODO: Should have a MODULE to encrypt transactions.
--			Ideally it would be the same to encrypt everything (transactions, blocks, addresses...).


MODULE createBlock (blockId, listTransaction, previousBlockId)
-- Step 3: Several transactions are put together and encrypted creating a block.
--		   Each block contains into it an identification of the previous block, wich chains the blocks.

	VAR
		blockId : integer;
		blockCreation : boolean;
		timestamp : integer;
		previousBlockId : 1..3;
		listBlock : array 1..10 of array 1..4 of unsigned word[10];
		blockTransactions : array 1..3 of integer;


	ASSIGN
		next(blockTransactions) := {listTransaction[1][1],listTransaction[2][1], listTransaction[3][1]};
		init(id) := 1;
		init(timestamp) := 1;
		next(blockId) := blockId + 1;
		next(timestamp) := timestamp + 1;
		next(blockCreation) := listBlock[blockId] = {blockId, timestamp, blockTransactions, previousBlockId};						


MODULE searchBlock(requester, adj1, adj2, listNode)
	
	VAR
		requester : 1..7;
		

	DEFINE

		hasNewBlock := listNode[requester][1] < listNode[adj1][1] |		--- Compares the last block of the requester 
					   listNode[requester][1] < listNode[adj2][1] |		--- and  adjacent node.
		 			   listNode[requester][1] < listNode[adj3][1];

	ASSIGN

		next(adj1) := case 
						requester = 1 : 3;
						requester = 2 : 3;
						requester = 3 : 1;
						requester = 4 : 1;
						requester = 5 : 1;
						TRUE : 0;
					esac;

		next(adj2) := case
						requester = 1 : 4;										
						requester = 3 : 2;
						requester = 4 : 3;
						requester = 5 : 4;
						TRUE : 0;							
					esac;


MODULE broadcast(sender, blockId)
-- Step 4: Once a node created a block, it should be broadcasted to the entire network.
	VAR
		sender : 1..7;
		blockId : 1..3;
		checkNodes : searchBlock(sender, adj1, adj2, adj3, listNode);
		upToDate : broadcast(sender, blockId);

	DEFINE

--		checkNodes := searchBlock(sender, adj1, adj2, adj3, listNode);	--- Verify if each one of the adjacent
																		--- nodes is up-to-date		
		sendLastBlock := checkNodes.hasNewBlock;

		
	ASSIGN

		next(listNode[sender][1]) :=  case	
										sendLastBlock : listNode[sender][1]+1;
										TRUE : listNode[sender][1];
									esac;


MODULE main
	VAR
		listTransaction : array 1..10 of array 1..4 of integer;  --listTransaction: [ID, from, to, amount]
		
		user1 : createUsers(1,8);
		user2 : createUsers(2,3);
		user3 : createUsers(3,15);
		
		t1 : createTransaction(1, user1, user2, 3, listTransaction);
		t2 : createTransaction(2, user1, user3, 5, listTransaction);
		t3 : createTransaction(3, user2, user1, 7, listTransaction);
		t4 : createTransaction(4, user3, user2, 4, listTransaction);
		t5 : createTransaction(5, user1, user2, 12, listTransaction);

	

		