MODULE createTransaction (idT, from, to, amount, listBalance, listTransaction)
--Step 1: A sender and a receiver create a transaction. It's just a value transfer from one to another.

	VAR
		fromHasBalance : boolean;
		transactionValue : integer;
		transactionId : integer;
		transaction : boolean;
		idT : integer;

	DEFINE
		fromHasBalance :=  listBalance[from] >= amount; --- Does the sender have enought balance?
		newBalanceFrom := listBalance[from] - amount; 	--- New sender balance.
		newBalanceTo := listBalance[to] + amount; 		--- New receiver balance.


	ASSIGN

		next(transaction) := case
							fromHasBalance : newBalanceFrom & newBalanceTo & listTransaction[idT] := {idT, from, to, amount} & idT := idT+1;
							TRUE : transaction;
						esac;


-- Step 2: #TODO: Should have a MODULE to encrypt transactions.
--			Ideally it would be the same to encrypt everything (transactions, blocks, addresses...).


MODULE createBlock (idB, timestamp, listTransaction, previousBlockId)
-- Step 3: Several transactions are put together and encrypted creating a block.
--		   Each block contains into it an identification of the previous block, wich chains the blocks.

	VAR
		idB : integer;
		blockCreation : boolean;
		timestamp : integer;
		previousBlockId : integer;
		listBlock := array 1..10 of array 1..4 of unsigned word[10];
		blockTransactions := array 1..3 of integer;


	ASSIGN
		next(blockTransactions) := {listTransaction[0][1],listTransaction[1][1], listTransaction[2][1]};
		init(id) := 1;
		init(timestamp) := 1;
		next(idB) := idB + 1;
		next(timestamp) := timestamp + 1;
		next(blockCreation) := listBlock[idB] = {idB, timestamp, blockTransactions, previousBlockId};						


-- #TODO: Define a peer-to-peer network.

MODULE searchBlock(requester, adj1, adj2, adj3, listNode)
	
	VAR
		requester : integer;
		listNode : array 1..5 of array 1..2 of integer;  --- Array of the node IDs and its last nodes.

	DEFINE

		hasNewBlock := listNode[requester][1] < listNode[adj1][1] |		--- Compares the last block of the requester 
					   listNode[requester][1] < listNode[adj2][1] |		--- and  adjacent node.
		 			   listNode[requester][1] < listNode[adj3][1];

	ASSIGN

		next(adj1) := case 
						requester = 1 : 3;
						requester = 2 : 3;
						requester = 3 : 1;
						requester = 4 : 1;
						requester = 5 : 1;
						TRUE : 0;
					esac;

		next(adj2) := case
						requester = 1 : 4;										
						requester = 3 : 2;
						requester = 4 : 3;
						requester = 5 : 4;
						TRUE : 0;							
					esac;

		next(adj3) := case
						requester = 1 : 5;										
						requester = 3 : 4;
						requester = 4 : 5;										
						TRUE : 0;
					esac;


MODULE broadcast(sender, blockId)
-- Step 4: Once a node created a block, it should be broadcasted to the entire network.
	VAR
		sender : integer;
		blockId : integer;

	DEFINE

		checkNodes : searchBlock(sender, adj1, adj2, adj3, listNode);	--- Verify if each one of the adjacent																		--- nodes is up-to-date
		
		sendLastBlock := checkNodes.hasNewBlock;

		upToDate := broadcast(sender, blockId)
	ASSIGN

		next(listNode[sender][1]) :=  case	
										sendLastBlock : listNode[sender][1]+1
										TRUE : listNode[sender][1];
									esac;


MODULE main
	VAR
		listBalance : array 1..5 of integer;
		listTransaction : array 1..10 of array 1..4 of integer;
		primeNumber : integer;
		n : integer;


		user : array 1..5 of unsigned word[1] := {a, b, c, d, e};

		t1 : process createTransaction(1, user[1],user[2], 35, listBalance, listTransaction);
		t2 : process createTransaction(primeNumber, user[2],user[3], 25, listBalance, listTransaction);
		t3 : process createTransaction(primeNumber, user[3],user[4], 15, listBalance, listTransaction);
		t4 : process createTransaction(primeNumber, user[4],user[5], 05, listBalance, listTransaction);
		t5 : process createTransaction(primeNumber, user[5],user[1], 35, listBalance, listTransaction);


	ASSIGN
		listBalance[1] := 50;
		--init(n) := 1;
		--next(n) := case 
		--			(n mod 2) != 0 & (n mod 3) != 0 & (n mod 5) != 0 & (n mod 7 != 0): primeNumber := n;
		--		esac;