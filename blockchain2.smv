MODULE Network
-- STEP 1: Create a peer-to-peer network of 5 nodes.

	VAR
		n1 : integer;  -- Each n is an array of [nID, Last_BlockID].
		n2 : integer;
		n3 : integer;
		n4 : integer;
		n5 : integer; 
		n6 : integer;
		n7 : integer;
		adj1 : integer;
		adj2 : integer;

	ASSIGN
	
		init(n1) := 0;
		init(n2) := 0;
		init(n3) := 0;
		init(n4) := 0;
		init(n5) := 0;
		init(n6) := 0;
		init(n7) := 0;

		init(adj1) := case
						n1 : n2;
						n2 : n3;
						n3 : n4;
						n4 : n5;
						n5 : n6;
						n6 : n7;
						n7 : n1;						
						TRUE : 0;
					esac;

		init(adj2) := case
						n7 : n6;
						n6 : n5;
						n5 : n4;
						n4 : n3;
						n3 : n2;
						n2 : n1;
						n1 : n7;
						TRUE : 0;
					esac;

MODULE createUsers(userId, userBalance)
--STEP2: Create 3 users with Balance.

	DEFINE 
		id := userId;
		balance := userBalance;

MODULE createTransaction(id, from, to, amount)

	VAR
		--transactionsList: array 1..5 of array 1..5 of integer;
		fromBal : from.balance;
		toBal : to.balance;
	DEFINE

		fromHasBalance :=  from.balance >= amount; --- Does the sender user have enough balance?

	ASSIGN
		next(fromBal) := case
						fromHasBalance: from.balance - amount;
						TRUE: from.balance;
					esac;
		next(toBal) := case
						fromHasBalance: to.balance + amount;
						TRUE: to.balance;
					esac;

		next(transactionsList[1][1]) := transactionsList[1][1] = 0 ? id : transactionsList[1][1];
		next(transactionsList[1][1]) := transactionsList[1][1] = 0 ? from : transactionsList[1][2];
		next(transactionsList[1][1]) := transactionsList[1][1] = 0 ? to : transactionsList[1][3];
		next(transactionsList[1][1]) := transactionsList[1][1] = 0 ? amount : transactionsList[1][4];
		next(transactionsList[1][1]) := transactionsList[1][1] = 0 ? 0 : transactionsList[1][5];

		next(transactionsList[1][1]) := transactionsList[2][1] = 0 ? id : transactionsList[2][1];
		next(transactionsList[1][1]) := transactionsList[2][1] = 0 ? from : transactionsList[2][2];
		next(transactionsList[1][1]) := transactionsList[2][1] = 0 ? to : transactionsList[2][3];
		next(transactionsList[1][1]) := transactionsList[2][1] = 0 ? amount : transactionsList[2][4];
		next(transactionsList[1][1]) := transactionsList[2][1] = 0 ? 0 : transactionsList[2][5];

		next(transactionsList[1][1]) := transactionsList[3][1] = 0 ? id : transactionsList[3][1];
		next(transactionsList[1][1]) := transactionsList[3][1] = 0 ? from : transactionsList[3][2];
		next(transactionsList[1][1]) := transactionsList[3][1] = 0 ? to : transactionsList[3][3];
		next(transactionsList[1][1]) := transactionsList[3][1] = 0 ? amount : transactionsList[3][4];
		next(transactionsList[1][1]) := transactionsList[3][1] = 0 ? 0 : transactionsList[3][5];







MODULE SearchBlocks(requesterID, adj1, adj2)
-- In this module, a n will look for new block with your adjacent ns.


	DEFINE
	hasNewBlock := nsList[requesterID][1] <= nsList[adj1][1] |  --If an adjacent LastBlockId is > requester_LastBlockId
				   nsList[requesterID][1] <= nsList[adj2][1];   -- then it has a new block to broadcast.

	ASSIGN

		next(adj1) := case 
						requester = 1 : 3;
						requester = 2 : 3;
						requester = 3 : 1;
						requester = 4 : 1;
						requester = 5 : 1;
						TRUE : 0;
					esac;

		next(adj2) := case
						requester = 1 : 4;										
						requester = 3 : 2;
						requester = 4 : 3;
						requester = 5 : 4;
						TRUE : 0;							
					esac;

MODULE broadcast(sender, blockId)
-- Step 4: Once a n created a block, it should be broadcasted to the entire network.
	VAR
		sender : word[5];
		blockId : 1..3;
		checkns : searchBlock(sender, adj1, adj2, nsList);
		
	DEFINE

--		checkns := searchBlock(sender, adj1, adj2, adj3, nsList);	--- Verify if each one of the adjacent
																		--- ns is up-to-date		
		sendLastBlock := checkns.hasNewBlock;
		
	ASSIGN

		next(nsList[sender][1]) :=  case	
										sendLastBlock : nsList[sender][1]+1;
										TRUE : nsList[sender][1];
									esac;


MODULE main
	VAR
		transactionsList : array 1..5 of array 1..5 of integer;  --transactionsList: [ID, in a block?]

--Creating users--
		user1 : process createUsers(1, 1);
		user2 : process createUsers(2, 8);
		user3 : process createUsers(3, 15);

--Creating transactions--
		t1 : process createTransaction(1, user1, user2, 3);
		t2 : process createTransaction(2, user1, user3, 4);
		t3 : process createTransaction(3, user2, user1, 7);
		t4 : process createTransaction(4, user3, user2, 3);
		t5 : process createTransaction(5, user1, user2, 12);

		







--Checklist:

--1- Create ns;
--2- Create users;
--3- Create transactions;
--	3.1- Update transactions list;
--4- Create blocks;
--	4.1- Update blocks list;
--	4.2- Update transactions list to inform transactions into a block;
--5- Search new Blocks;
--6- Broadcast new blocks;