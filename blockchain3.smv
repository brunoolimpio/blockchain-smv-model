MODULE P2PNetwork()

	VAR
		IPSent: boolean;
		IPReceived: boolean;
		connectSeed: boolean;
		versionSent: boolean;
		verack: boolean;
		networkOK: boolean;
	
	ASSIGN
		init(IPSent) := FALSE;
		init(IPReceived) := FALSE;
		init(connectSeed) := FALSE;
		init(versionSent) := FALSE;
		init(verack) := FALSE;
		init(networkOK) := FALSE;



		next(IPSent) := {TRUE, FALSE};
		next(IPReceived) := IPSent = TRUE ? {TRUE, FALSE} : FALSE;
		next(connectSeed) := (IPSent = TRUE & IPReceived = TRUE) ? TRUE : FALSE;
		next(versionSent) := connectSeed = TRUE ? {TRUE, FALSE} : FALSE;
		next(verack) := versionSent = TRUE ? {TRUE, FALSE} : FALSE;
		next(networkOK) := verack = TRUE ? TRUE : FALSE;



MODULE createUser(iduser, initBalance)
	
	FROZENVAR
		id : integer;

	VAR
		balance : integer;

	ASSIGN
		init(id) := iduser;
		init(balance) := initBalance;


MODULE createTransaction(idTrans, from, to, amount)
	
	FROZENVAR
		id : integer;

	VAR
		validTransaction : boolean;

	DEFINE
		fromHasBalance :=  from.balance >= amount; --- Does the sender user have enough balance?
		newfromBalance := fromHasBalance? from.balance - amount : from.balance;
		newToBalance := fromHasBalance? to.balance + amount : to.balance;
		--updateFromBalance := fromHasBalance ? updateBalances(from, newfromBalance) : updateBalances(from, from.balance);
		--updateToBalance := fromHasBalance ? updateBalances(to, newToBalance) : updateBalances(to, to.balance);

	ASSIGN	
		init(id) := idTrans;
		validTransaction := fromHasBalance ? TRUE : FALSE;
		next(from.balance) := validTransaction ? newfromBalance : from.balance;
		next(to.balance) := validTransaction ? newToBalance : to.balance;

MODULE CreateBlock(idlastBlock, txa, txb)
		
	FROZENVAR
		nonce :integer;
	DEFINE
		id := idlastBlock + 1;
		hashPrevBlock := idlastBlock;
		--hash := id + 10;
		hash := unsigned word [5](nonce) + unsigned word [5](txa.id) + unsigned word [5](txb.id) + unsigned word [5](hashPrevBlock);
		--hash2 := unsigned word [2](txa.from.id) + unsigned word [2](txb.from.id + id);
		--blockHash := unsigned word[32] (hash);

	ASSIGN
		init(nonce) := 00000;


MODULE main
	VAR
		no1 : P2PNetwork();
		no2 : P2PNetwork();
		no3 : P2PNetwork();
		no4 : P2PNetwork();
		no5 : P2PNetwork();
		no6 : P2PNetwork(); 
		user1 : createUser(1, 1);
		user2 : createUser(2, 10);
		user3 : createUser(3, 12);
		user4 : createUser(4, 35);
		tx1 : createTransaction(2, user1, user3, 10);
		tx2 : createTransaction(3, user4, user2, 19);
		--tx3 : createTransaction(3, user3, user4, 11);
		--tx4 : createTransaction(4, user2, user1, 6);
		--tx5 : createTransaction(5, user4, user3, 12); 
		block1 : CreateBlock(1, tx1, tx2);


	DEFINE

	--INSERINDO TX1 na lista de transações --		
		transactionsList[1][1] := tx1.id;
		transactionsList[1][2] := tx1.from.id;
		transactionsList[1][3] := tx1.to.id;
		transactionsList[1][4] := tx1.amount;

	--INSERINDO TX2 na lista de transações --
		transactionsList[2][1] := tx2.id;
		transactionsList[2][2] := tx2.from.id;
		transactionsList[2][3] := tx2.to.id;
		transactionsList[2][4] := tx2.amount;

--Gerador de compiladores - André Luiz


-- Criar uma matriz de saldos do usuário.
-- Criar um contador pra matriz de de transações e usar um if ou case pra acessar o índice.
-- Estudar INVAR para constraints do modelo (ex. saldo <=0)

-- Explicar uso MSAT!!

-- COMANDO PARA RODAR O SMV: go_msat; msat_pick_state; msat_simulate -v;