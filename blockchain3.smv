MODULE P2PNetwork()

	VAR
		IPSent: boolean;
		IPReceived: boolean;
		connectSeed: boolean;
		versionSent: boolean;
		verack: boolean;
	
	ASSIGN
		init(IPSent) := FALSE;
		init(IPReceived) := FALSE;
		init(connectSeed) := FALSE;
		init(versionSent) := FALSE;
		init(verack) := FALSE;



		next(IPSent) := {TRUE, FALSE};
		next(IPReceived) := IPSent = TRUE ? {TRUE, FALSE} : FALSE;
		next(connectSeed) := (IPSent = TRUE & IPReceived = TRUE) ? TRUE : FALSE;
		next(versionSent) := connectSeed = TRUE ? {TRUE, FALSE} : FALSE;
		next(verack) := versionSent = TRUE ? {TRUE, FALSE} : FALSE;


MODULE createUser(initBalance)
	VAR
		balance : integer;

	ASSIGN
		init(balance) := initBalance;

MODULE createTransaction(id, from, to, amount)
	VAR
		transaction : array 1..10 of array 1..5 of integer; --Array of [ID, used?, from, to, amount]
		used : {0,1}; -- Defined as a set instead of boolean in order to use as "transaction" array assignment.

	DEFINE		
		fromHasBalance :=  from.balance >= amount; --- Does the sender user have enough balance?

	ASSIGN	
		init(used) := 0;
		next(from.balance) := fromHasBalance ? from.balance - amount : from.balance;
		next(to.balance) := fromHasBalance ? to.balance + amount : to.balance;
		--next(transaction[id][1]) := id;
		--next(transaction[id][2]) := self.from;   --PORQUE ESTÃO QUEBRANDO??
		--next(transaction[id][3]) := to;
		--next(transaction[id][5]) := used;
		next(used) := fromHasBalance ? 1 : 0; 


MODULE updateUTXO(txid, outIndex, value)
	
	ASSIGN
		UTXO[txid][outIndex] := value;


MODULE CreateBlock(hashPrevBlock, transactions)
-- Steps do create a block ---
-- !! Check block messages in https://en.bitcoin.it/wiki/Protocol_rules#.22block.22_messages
-- 1) Block structure (Magic nº, Blocksize, Blockheader, TransactionCounter, Transactions) 
-- 2) Block Header (Version, hashPrevBlock, hashMerkleTree, Time, Bits, Nonce)
-- 3) Transactions(list containing hashes all transactions inside the block)
	
	CONSTANTS
		magicNo;

	VAR
		
		blockSize: integer;
		transactionCounter: integer;
		transactionsList: array 1..10 of word[32];
		version: integer;
		hashPrevBlock: word[64];
		hashMerkleTree: word[64];
		time: integer;  -- current timestamp
		bits: integer;  -- Current target to the difficulty;
		txnListEmpty: boolean;
		blockHash: word[32];
		blockHashSatisfyNonce: boolean;
		expired: boolean;
		

	DEFINE
		magicNo := "0xD9B4BEF9";  -- This is the Magic No, and it's always the same.
		hashMerkleTree := "2b12fcf1b09288fcaff797d71e950e71ae42b91e8bdb2304758dfcffc2b620e3"; --Just an arbitrary hash to test de model.
		txnListEmpty := transactions[1] = 0 ? TRUE : FALSE;
		blockHashSatisfyNonce := [TRUE, FALSE];
		transactionsList := transactions;
		
	ASSIGN
		init(TransactionCounter) := 0;
		init(txnListEmpty) := TRUE;



MODULE main
	VAR
		transaction : array 1..10 of array 1..5 of integer; --Array of [ID, used?, from, to, amount]
		no1 : P2PNetwork();
		no2 : P2PNetwork();
		no3 : P2PNetwork();
		no4 : P2PNetwork();
		no5 : P2PNetwork();
		no6 : P2PNetwork();
		user1 : createUser(0);
		user2 : createUser(10);
		user3 : createUser(6);
		user4 : createUser(35);
		tx1 : createTransaction(2, user1, user3, 10);
		tx2 : createTransaction(3, user4, user2, 19);
		--tx3 : createTransaction(3, user3, user4, 11);
		--tx4 : createTransaction(4, user2, user1, 6);
		---tx5 : createTransaction(5, user4, user3, 12); 
		UTXO: array 1..10 of array 1..2 of integer; --Array of unspent transaction outputs [user, value]

	ASSIGN
		next(UTXO) := updateUTXO(tx1.id, 1, tx1.amount);
