MODULE createNode(nodeId)

	FROZENVAR
		id: integer;

	VAR
		IPSent: boolean;
		IPReceived: boolean;
		connectSeed: boolean;
		versionSent: boolean;
		verack: boolean;
		networkOK: boolean;
		lastBlockId: integer;
		--lock : boolean;

	
	ASSIGN
		init(id) := nodeId;
		init(IPSent) := FALSE;
		init(IPReceived) := FALSE;
		init(connectSeed) := FALSE;
		init(versionSent) := FALSE;
		init(verack) := FALSE;
		init(networkOK) := FALSE;
		init(lastBlockId) := 0;


		next(IPSent) := {TRUE, FALSE};
		next(IPReceived) := IPSent = TRUE ? {TRUE, FALSE} : FALSE;
		next(connectSeed) := (IPSent = TRUE & IPReceived = TRUE) ? TRUE : FALSE;
		next(versionSent) := connectSeed = TRUE ? {TRUE, FALSE} : FALSE;
		next(verack) := versionSent = TRUE ? {TRUE, FALSE} : FALSE;
		next(networkOK) := verack = TRUE ? TRUE : FALSE;

MODULE createUser(idUser, initBalance)
	
	FROZENVAR
		id : integer;

	VAR
		balance : integer;

	ASSIGN
		init(id) := idUser;
		init(balance) := initBalance;


MODULE createTransaction(idTrans, from, to, amount)
	
	FROZENVAR
		id : integer;
		blockId : integer;


	VAR
		validTransaction : boolean;

	DEFINE
		fromHasBalance :=  from.balance >= amount; --- Does the sender user have enough balance?
		newfromBalance := fromHasBalance? from.balance - amount : from.balance;
		newToBalance := fromHasBalance? to.balance + amount : to.balance;

	ASSIGN	
		init(id) := idTrans;
		validTransaction := fromHasBalance ? TRUE : FALSE;
		next(from.balance) := validTransaction ? newfromBalance : from.balance;
		next(to.balance) := validTransaction ? newToBalance : to.balance;

MODULE createBlock(blockId, txa, txb)
		
	FROZENVAR
		nonce : integer;
		id : integer;
		newestBlock : boolean;
	VAR
		previousBlock : integer;
		update : updateBlockIndex(blockId);
	DEFINE
		hash := signed word [5](nonce) + signed word [5](txa.id) + signed word [5](txb.id); --+ unsigned word [5](hashPrevBlock);
		hash2 := signed word [5](nonce) + signed word [5](txb.id) + signed word [5](txa.id); --+ unsigned word [5](hashPrevBlock);
		

	ASSIGN
		init(nonce) := 0000019;
		init(id) := blockId;
		init(previousBlock) := blockId - 1;
		next(previousBlock.newestBlock) := previousBlock > 0 ? FALSE : 0;
		init(newestBlock) := TRUE;
		init(txa.blockId) := id;
		init(txb.blockId) := id;

MODULE updateBlockIndex(blockId)
	VAR
		lastBlock : integer;

	ASSIGN
		init(lastBlock) := blockId;

MODULE updateNode(node, block)
	VAR
		lastBlockOnNode : integer;

	DEFINE
		nodeOnline := node.networkOK ? TRUE : FALSE;
		isUpToDate := lastBlockOnNode >= block; -- 

	ASSIGN
		init(lastBlockOnNode) := node.lastBlockId;


MODULE main
	VAR
		node1 : createNode(1);
		node2 : createNode(2);
		node3 : createNode(3);
		node4 : createNode(4);
		node5 : createNode(5);
		user1 : createUser(1, 1);
		user2 : createUser(2, 10);
		user3 : createUser(3, 12);
		user4 : createUser(4, 35);
		user5 : createUser(5, 22);
		user6 : createUser(6, 2);
		tx1 : createTransaction(01, user1, user3, 10);
		tx2 : createTransaction(02, user4, user2, 19);
		tx3 : createTransaction(3, user5, user6, 11);
		--tx4 : process createTransaction(4, user2, user1, 6);
		--tx5 : process createTransaction(5, user4, user3, 12); 
		block1 : createBlock(1, tx3, tx5);
		block2 : createBlock(2, tx1, tx4);
		--lastBlock : integer;
	

	DEFINE

	--INSERINDO TX1 na lista de transações --		
		transactionsList[1][1] := tx1.validTransaction ? tx1.id : 0;
		transactionsList[1][2] := tx1.validTransaction ? tx1.from.id : 0;
		transactionsList[1][3] := tx1.validTransaction ? tx1.to.id : 0;
		transactionsList[1][4] := tx1.validTransaction ? tx1.amount :0;

	--INSERINDO TX2 na lista de transações --
		transactionsList[2][1] := tx2.validTransaction ? tx2.id : 0;
		transactionsList[2][2] := tx2.validTransaction ? tx2.from.id : 0;
		transactionsList[2][3] := tx2.validTransaction ? tx2.to.id : 0;
		transactionsList[2][4] := tx2.validTransaction ? tx2.amount : 0;

		--blocksList[1] := block1.id;
--Gerador de compiladores - André Luiz


-- Criar uma matriz de saldos do usuário.
-- Criar um contador pra matriz de transações e usar um if ou case pra acessar o índice.
-- Estudar INVAR para constraints do modelo (ex. saldo <=0)
-- Tentar no módulo P2P chamar o módulo pra atualizar o índice (lock)

-- Pensar referência a mineração. Talvez separar criação de blocos e "comparação de hashes".

-- COMANDO PARA RODAR O SMV: reset; go_msat; msat_pick_state; msat_simulate -v;
-- COMANDO ALTERNATIVO: reset; go_msat; msat_simulatepick_state -v;
