MODULE createNode(nodeId)

	VAR
		IPSent: boolean;
		IPReceived: boolean;
		connectSeed: boolean;
		versionSent: boolean;
		verack: boolean;
		networkOK: boolean;
		lastBlockId: 0..10;
	
	ASSIGN
		init(IPSent) := TRUE;
		init(IPReceived) := FALSE;
		init(connectSeed) := FALSE;
		init(versionSent) := FALSE;
		init(verack) := FALSE;
		init(networkOK) := FALSE;
		init(lastBlockId) := 0;


		next(IPSent) := TRUE;
		next(IPReceived) := IPSent = TRUE ? TRUE : FALSE;
		next(connectSeed) := (IPSent = TRUE & IPReceived = TRUE) ? TRUE : FALSE;
		next(versionSent) := connectSeed = TRUE ? TRUE : FALSE;
		next(verack) := versionSent = TRUE ? TRUE : FALSE;
		next(networkOK) := verack = TRUE ? TRUE : FALSE;

MODULE createUser(idUser, initBalance)

	VAR
		balance : 0..400;
		busy : boolean;

	ASSIGN
		init(balance) := initBalance;

	TRANS !update -> conserve ;
	
	DEFINE
		conserve := (next(balance) = balance);

MODULE createTransaction(idTrans, from, to, amount)
	
	FROZENVAR
		blockId : 0..10;


	DEFINE
		validTransaction :=  !from.busy & !to.busy & from.balance >= amount; --- Does the sender user have enough balance?
		newFromBalance := from.balance - amount;
		newToBalance :=  to.balance + amount;

	TRANS
		validTransaction -> (next(from.balance)= newFromBalance) & 
							(next(to.balance)=newToBalance) & 
							(next(from.busy)=!from.busy) & 
							(next(to.busy)=!to.busy);


MODULE createBlock(idBloco, txa, txb)
	FROZENVAR
		id : 0..10;

	ASSIGN
		init(id) := idBloco;
		init(txa.blockId) := validBlock ? id : 0;
		init(txb.blockId) := validBlock ? id : 0;
		

	DEFINE
		validBlock := txa.validTransaction & txb.validTransaction;
		nonce := signed word[32](190);
		--hash := validBlock ? (nonce :: signed word [32](txa.to) :: signed word [32](txb.to) :: signed word[32](previousBlock))
		--		: unsigned word[128](0);



MODULE updateNode(node, block)

	DEFINE
		lastNodeBlock := node.lastBlockId;
		blockToUpdate := block.validBlock ? block.id : -1;
		shouldUpdate := lastNodeBlock <= blockToUpdate;	
	ASSIGN
		next(node.lastBlockId) := shouldUpdate ? lastNodeBlock : block.id;


MODULE main
	
	VAR
		
		node1 : createNode(self);
		node2 : createNode(self);
		node3 : createNode(self);
		node4 : createNode(self);

		user1 : createUser(self, 1);
		user2 : createUser(self, 10);
		user3 : createUser(self, 12);
		user4 : createUser(self, 35);
		user5 : createUser(self, 22);
		user6 : createUser(self, 2);

		tx1 : createTransaction(self, user1, user3, 10); -- SHOULD BE INVALID!
		tx2 : createTransaction(self, user4, user2, 19);
		tx3 : createTransaction(self, user5, user6, 11);
		tx4 : createTransaction(self, user2, user1, 6);
		tx5 : createTransaction(self, user4, user3, 12);
		tx6 : createTransaction(self, user2, user1, 4);
		tx7 : createTransaction(self, user6, user1, 1);
		tx8 : createTransaction(self, user3, user4, 7);


		block1 : createBlock(1, tx3, tx5);
		block2 : createBlock(2, tx1, tx4); -- SHOULD BE INVALID!
		block3 : createBlock(3, tx2, tx6);
		block4 : createBlock(4, tx7, tx8);

		updateNode1 : updateNode(node1, block3);
		updateNode2 : updateNode(node2, block4);
		updateNode3 : updateNode(node3, block2);

		ASSIGN

			init(user1.busy) := TRUE;
			init(user3.busy) := TRUE;

	DEFINE

		user1.update := tx1.validTransaction | tx4.validTransaction | tx6.validTransaction | tx7.validTransaction;
		user2.update := tx2.validTransaction | tx4.validTransaction | tx6.validTransaction;
		user3.update := tx1.validTransaction | tx5.validTransaction | tx8.validTransaction;
		user4.update := tx2.validTransaction | tx5.validTransaction | tx8.validTransaction;
		user5.update := tx3.validTransaction;
		user6.update := tx3.validTransaction | tx7.validTransaction;

		block1.previousBlock := block1.validBlock ? 0 : -1;
		block2.previousBlock := case 
									block2.validBlock : case
															block1.validBlock : block1.id;
														esac;
									TRUE : -1;
								esac;
		block3.previousBlock := case
									block3.validBlock : case
															block2.validBlock : block2.id;
															block1.validBlock : block1.id;
														esac;
									TRUE : -1;
								esac;

		block4.previousBlock := case
									block4.validBlock : case
															block3.validBlock : block3.id;
															block2.validBlock : block2.id;
															block1.validBlock : block1.id;
														esac;
									TRUE : -1;
								esac;

		user1.newbalance := user1.balance - (tx1.blockId != 0 ? tx1.amount : 0) + 
									   (tx4.blockId != 0 ? tx4.amount : 0) + 
									   (tx6.blockId != 0 ? tx6.amount : 0) + 
									   (tx7.blockId != 0 ? tx7.amount : 0);
		
		user2.newbalance := user2.balance + (tx2.blockId != 0 ? tx2.amount : 0) -
									   (tx4.blockId != 0 ? tx4.amount : 0) -
									   (tx6.blockId != 0 ? tx6.amount : 0);

		user3.newbalance := user3.balance + (tx1.blockId != 0 ? tx1.amount : 0) +
									   (tx5.blockId != 0 ? tx5.amount : 0) -
									   (tx8.blockId != 0 ? tx8.amount : 0);

		user4.newbalance := user4.balance - (tx2.blockId != 0 ? tx2.amount : 0) -
									   (tx5.blockId != 0 ? tx5.amount : 0) +
									   (tx8.blockId != 0 ? tx8.amount : 0);

		user5.newbalance := user5.balance + (tx3.blockId != 0 ? tx3.amount : 0);

		user6.newbalance := user6.balance + (tx3.blockId != 0 ? tx3.amount : 0) - 
									   (tx7.blockId != 0 ? tx7.amount : 0);


--	SPEC AG (user1.balance = 10);


-- COMANDOS PARA RODAR O SMV: 

-- 1) no command: cd "C:\Program Files (x86)\nuXmv-1.1.1-win64\bin"
-- 2)  
-- 3) reset; go_msat; msat_pick_state; msat_simulate -v;


--- Procurar tese do Marcelo Brogliato - FGV;

--- O deadlock está na criação de tx diversas com o mesmo usuário.

-- Pegar as blockchains do Marcelo e do Ethereum e comparar.

-- Verificar trabalho do Daniel Arena sobre o Reo pra modelar contratos;
-- Fazer revisão sobre o que existe de blockchain;



-- CRIAR BLOCOS SEQUENCIALMENTE;
	-- criar VARs para emUso foiUsado no createBlock;

-- ELIMINAR CONCORRÊNCIA ENTRE TXN

-- Descrever as condições de SAT e UNSAT 

-- Criar um makefile com o script que gera o código nuxmv.